// Generated by CoffeeScript 1.6.3
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

var YAML = require('yamljs');
var fs = require('fs');
module.exports = function(BasePlugin) {
  var RestAPI, _ref;
  return RestAPI = (function(_super) {
    __extends(RestAPI, _super);

    function RestAPI() {
      _ref = RestAPI.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    RestAPI.prototype.name = 'restapi';

    RestAPI.prototype.config = {
      channel: '/restapi',
      maxFilenameLen: 40,
      injectHelper: null,
      securityToken: null
    };

    RestAPI.prototype.getSecurityToken = function() {
      var securityToken;
      securityToken = this.getConfig().securityToken;
      if (!securityToken) {
        docpad.warn('You are currently running the REST API Plugin without a security token, you should set one');
      }
      return securityToken;
    };

    RestAPI.prototype.serverExtend = function(opts) {
      var channel, createFileFromRequest, deleteFilesFromRequest, docpad, getFilesFromRequest, getUniqueRelativePath, plugin, prepareCollection, prepareFile, securityToken, sendError, sendSuccessData, sendSuccessMessage, server, updateFileFromRequest;
      plugin = this;
      docpad = this.docpad;
      server = opts.server;
      channel = this.getConfig().channel;
      sendSuccessData = function(res, data, message) {
        return res.send({
          success: true,
          message: message || "Action completed successfully",
          data: data
        });
      };
      sendSuccessMessage = function(res, message) {
        return res.send({
          success: true,
          message: message
        });
      };
      sendError = function(res, err, code) {
        if (code == null) {
          code = 200;
        }
        return res.send(code, {
          success: false,
          message: err.message
        });
      };
      prepareFile = function(file, additionalFields) {
        var field, fields, result, _i, _len, _ref1;
        result = {};
        fields = ['id', 'filename', 'relativePath', 'url', 'urls', 'contentType', 'encoding', 'content', 'contentRendered'];
        if (additionalFields == null) {
          additionalFields = [];
        }
        if (!Array.isArray(additionalFields)) {
          additionalFields = String(additionalFields).split(/[,\s]+/);
        }
        if (additionalFields.length === 1 && additionalFields[0] === 'all') {
          result = file.toJSON();
        } else {
          result.meta = file.getMeta();
          _ref1 = fields.concat(additionalFields);
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            field = _ref1[_i];
            result[field] = file.get(field);
          }
        }
        return result;
      };
      prepareCollection = function(collection, additionalFields) {
        var result;
        result = [];
        collection.each(function(file) {
          return result.push(prepareFile(file, additionalFields));
        });
        return result;
      };
      getUniqueRelativePath = function(relativePath) {
        var basename, extensions, file, parts, relativeDirPath, result;
        result = relativePath;
        extensions = relativePath.replace(/^.+?\./, '');
        while ((file = docpad.getDatabase().where({
            relativeBase: result.replace(/\..*$/, '')
          })[0])) {
          basename = file.get('basename');
          relativeDirPath = file.get('relativeDirPath');
          parts = /^(.+?)-([0-9]+)$/.exec(basename);
          if (parts) {
            basename = parts[1] + '-' + (parseInt(parts[2], 10) + 1);
          } else {
            basename += '-2';
          }
          result = relativeDirPath + '/' + basename;
          if (extensions) {
            result += '.' + extensions;
          }
        }
        return result;
      };
      getFilesFromRequest = function(req, next) {
        var collection, collectionName, err, extension, files, filter, limit, mime, offset, page, pageOpts, queryOpts, relativePath, result, sortOpts, _ref1, _ref2;
        files = null;
        queryOpts = null;
        sortOpts = null;
        pageOpts = null;
        relativePath = req.params[0] || null;
        collectionName = req.params.collectionName;
        mime = req.query.mime || null;
        extension = req.query.extension || null;
        page = req.query.page || null;
        limit = (_ref1 = req.query.limit) != null ? _ref1 : 10;
        offset = (_ref2 = req.query.offset) != null ? _ref2 : null;
        filter = req.query.filter;
        collection = docpad.getCollection(collectionName);
        if (!collection) {
          err = new Error("Couldn't find the collection: " + collectionName);
          return next(err);
          err;
        }
        if ((page != null) || (limit != null) || (offset != null)) {
          if (pageOpts == null) {
            pageOpts = {};
          }
          if (page != null) {
            pageOpts.page = parseInt(page, 10);
          }
          if (limit != null) {
            pageOpts.limit = parseInt(limit, 10);
          }
          if (offset != null) {
            pageOpts.offset = parseInt(offset, 10);
          }
        }
        if (filter) {
          try {
            queryOpts = JSON.parse(filter);
          } catch (_error) {
            err = _error;
            err = new Error("Failed to parse your custom filter: " + (JSON.stringify(filter)));
            return next(err);
            err;
          }
        }
        if (relativePath) {
          if (queryOpts == null) {
            queryOpts = {};
          }
          queryOpts.$or = {
            relativePath: process.platform.match(/^win32/) ? relativePath.replace(/\//g, '\\') : relativePath,
            relativeDirPath: relativePath.replace(/[\/\\]+$/, '')
          };
        }
        if (extension) {
          if (queryOpts == null) {
            queryOpts = {};
          }
          queryOpts.extensions = {
            $has: extension
          };
        }
        if (mime) {
          if (queryOpts == null) {
            queryOpts = {};
          }
          queryOpts.outContentType = {
            $like: mime
          };
        }
        result = queryOpts || sortOpts || pageOpts ? collection.findAll(queryOpts, sortOpts, pageOpts) : collection;
        return next(null, result);
        return result;
      };
      deleteFilesFromRequest = function(req, next) {
        var TaskGroup;
        TaskGroup = require('taskgroup').TaskGroup;
        return getFilesFromRequest(req, function(err, files) {
          var tasks;
          if (err) {
            return next(err);
          }
          if (files.length === 0) {
            return next(null, files);
          }
          tasks = new TaskGroup().setConfig({
            concurrency: 0
          }).once('complete', function(err) {
            if (err) {
              return next(err);
            }
            return docpad.action('generate', {
              reset: false
            }, function(err) {
              return next(err, files);
            });
          });
          files.each(function(file) {
            return tasks.addTask(function(complete) {
              return file.deleteSource(function(err) {
                if (err) {
                  return complete(err);
                }
                  fs.unlink(file.get('outPath'), function(err) {
                      if (err) console.log(err);
                  });
                docpad.getDatabase().remove(file);
                return complete();
              });
            });
          });
          return tasks.run();
        });
      };
      createFileFromRequest = function(req, next) {
        var collection, collectionName, config, docpadConfig, err, file, fileAttributes, fileMetaAttributes, fullDirPath, fullPath, key, relativePath, value, _ref1, _ref2, _ref3;
        docpadConfig = docpad.getConfig();
        config = plugin.getConfig();
        collectionName = req.params.collectionName;
        relativePath = req.params[0];
        collection = docpad.getCollection(collectionName);
        if (!collection) {
          err = new Error("Couldn't find the collection: " + collectionName);
          return next(err);
          err;
        }
        if (!relativePath) {
          err = new Error("No relativePath to place the file specified");
          return next(err);
          err;
        }
        var originRelativePath = relativePath;
        relativePath = getUniqueRelativePath(relativePath);
        fullDirPath = ((_ref1 = docpadConfig[collectionName + 'Paths']) != null ? _ref1[0] : void 0) || null;
        if (fullDirPath) {
          fullPath = "" + fullDirPath + "/" + relativePath;
        }
        fileMetaAttributes = {};
        _ref2 = req.body;
        for (key in _ref2) {
          if (!__hasProp.call(_ref2, key)) continue;
          value = _ref2[key];
          if (key !== 'content') {
            fileMetaAttributes[key] = value;
          }
        }
        fileAttributes = {
          data: req.body.content || '',
          relativePath: relativePath,
          fullPath: fullPath,
          meta: fileMetaAttributes
        };
        file = docpad.createModel(fileAttributes);
        if ((_ref3 = config.injectHelper) != null) {
          _ref3.call(plugin, file);
        }
//        docpad.getDatabase().add(file);

          var path = docpad.config.srcPath + '/documents/' + originRelativePath;
          var metaData = file.meta.toJSON();
          var metaContent = metaData.content;
          delete metaData.content;
          delete metaData.id;
          delete metaData.filename;
          delete metaData.relativePath;
          delete metaData.url;
          delete metaData.urls;
          delete metaData.contentType;
          delete metaData.encoding;
          delete metaData.contentRendered;
          var yamlString = YAML.stringify(metaData, 8, 4).trim();
          var doc = "---\n" + yamlString + "\n---\n" + metaContent;
          fs.exists(path, function(exists) {
              if (exists) {
                  fs.unlink(path, function(err) {
                      if (!err) {
                          fs.writeFile(path, doc, function(err) {
                              next(err, file);
                          });
                      } else {
                          next(err, file);
                      }
                  });
              } else {
                  var pathDir = path.replace(/\/[^\/]*$/, '');
                  fs.exists(pathDir, function(exists) {
                      if (exists) {
                          fs.writeFile(path, doc, function(err) {
                              next(err, file);
                          });
                      } else {
                          fs.mkdir(pathDir, function(err) {
                              if (err) console.log(err);
                              fs.writeFile(path, doc, function(err) {
                                  next(err, file);
                              });
                          })
                      }
                  });
              }
          });

//        file.writeSource({
//          cleanAttributes: true
//        }, function(err) {
//          if (err) {
//            return next(err, file);
//          }
//          return docpad.action('generate', {
//            reset: false
//          }, function(err) {
//            return next(err, file);
//          });
//        });
        return file;
      };
      updateFileFromRequest = function(req, next) {
        var collection, collectionName, err, file, fileMetaAttributes, key, relativePath, setMeta, value, writeSourceOptions, _ref1;
        collectionName = req.params.collectionName;
        relativePath = req.params[0];
        collection = docpad.getCollection(collectionName);
        if (!collection) {
          err = new Error("Couldn't find the collection: " + collectionName);
          return next(err);
          err;
        }
        if (!relativePath) {
          err = new Error("No relativePath to find the file specified");
          return next(err);
          err;
        }
        file = collection.where({
          relativePath: process.platform.match(/^win32/) ? relativePath.replace(/\//g, '\\') : relativePath
        })[0];
        if (!file) {
          err = new Error("Couldn't find the file at the relative path: " + relativePath);
          return next(err);
          err;
        }
        setMeta = false;
        fileMetaAttributes = {};
        _ref1 = req.body;
        for (key in _ref1) {
          if (!__hasProp.call(_ref1, key)) continue;
          value = _ref1[key];
          setMeta = true;
          if (key !== 'content') {
            fileMetaAttributes[key] = value;
          }
        }
        if (setMeta) {
          file.setMeta(fileMetaAttributes);
        }
        writeSourceOptions = {};
        writeSourceOptions.cleanAttributes = true;
        if (req.body.content != null) {
          writeSourceOptions.content = req.body.content;
        }

          var path = docpad.config.srcPath + '/documents/' + relativePath;
          var metaData = file.meta.toJSON();
          var metaContent = metaData.content;
          delete metaData.content;
          delete metaData.id;
          delete metaData.filename;
          delete metaData.relativePath;
          delete metaData.url;
          delete metaData.urls;
          delete metaData.contentType;
          delete metaData.encoding;
          delete metaData.contentRendered;
          var yamlString = YAML.stringify(metaData, 8, 4).trim();
          var doc = "---\n" + yamlString + "\n---\n" + metaContent;
          fs.exists(path, function(exists) {
              if (exists) {
                  fs.unlink(path, function(err) {
                      if (!err) {
                          fs.writeFile(path, doc, function(err) {
                              next(err, file);
                          });
                      } else {
                          next(err, file);
                      }
                  });
              } else {
                  var pathDir = path.replace(/\/[^\/]*$/, '');
                  fs.exists(pathDir, function(exists) {
                      if (exists) {
                          fs.writeFile(path, doc, function(err) {
                              next(err, file);
                          });
                      } else {
                          fs.mkdir(pathDir, function(err) {
                              if (err) console.log(err);
                              fs.writeFile(path, doc, function(err) {
                                  next(err, file);
                              });
                          })
                      }
                  });
              }
          });


//        file.writeSource(writeSourceOptions, function(err) {
//          if (err) {
//            return next(err, file);
//          }
//          return docpad.action('generate', {
//            reset: false
//          }, function(err) {
//            return next(err, file);
//          });
//        });
        return file;
      };
      /*
      			# Upload a file
      			server.post "#{channel}/upload", (req, res) ->
      				# Requires
      				safefs = require('safefs')

      				successful = []
      				failed = []
      				currentlyUploading = []
      				count = 0

      				uploadFile = (file) ->
      					path = file.path
      					origName = name = docpadConfig.filesPaths[0] + '/' + file.name
      					renameCounter = 0

      					# save an uploaded file
      					save = ->  safefs.rename path, name, (err) ->
      						unless err
      							if renameCounter
      								successful.push
      									origName: file.name
      									newName: name.replace(docpadConfig.filesPaths[0] + '/', '')
      							else
      								successful.push
      									name: file.name
      						else
      							console.log err
      							failed.push
      								file: file.name
      								error: err
      						unless --count
      							if successful.length + failed.length is 1
      								return res.send(if successful.length then (success: successful) else (success: false, error: failed))
      							res.send
      								success: successful
      								error: failed

      					# Save an uploaded file with a unique name
      					saveUnique = (exists) ->
      						# Name is not unique, try again
      						if (exists or currentlyUploading.indexOf(name) > -1)
      							name = origName.replace(/(.*?)(\..*)/, '$1-' + (++renameCounter) + '$2')
      							return safefs.exists(name, saveUnique)
      						# Unique name found, let's save it
      						currentlyUploading.push(name);
      						save()

      					# Save each uploaded file
      					safefs.exists(name, saveUnique)

      				# Iterate through each uploaded file
      				for own key of req.files
      					if req.files[key].name
      						count++
      						uploadFile req.files[key]

      				# If no work to be done, let the user know
      				unless count
      					res.send(error: 'No Files specified')
      */

      securityToken = this.getSecurityToken();
      if (securityToken) {
        docpad.log('info', "REST API started on channel " + channel + " with security token " + securityToken);
      }
      server.all("" + channel + "/*", function(req, res, next) {
        var err;
        res.header('Access-Control-Allow-Origin', '*');
        res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');
        res.header('Access-Control-Allow-Headers', 'Content-Type,X-Requested-With');
        if (req.method !== 'OPTIONS') {
          if (req.query.securityToken !== plugin.getSecurityToken()) {
            err = new Error('Incorrect security token');
            if (err) {
              return sendError(res, err);
            }
          }
        }
        return next();
      });
      server.get("" + channel + "/_collections/", function(req, res) {
        var key, result, value, _ref1;
        result = [];
        result.push({
          id: 'database',
          length: docpad.getDatabase().length
        });
        _ref1 = docpad.getCollections();
        for (key in _ref1) {
          if (!__hasProp.call(_ref1, key)) continue;
          value = _ref1[key];
          result.push({
            id: key,
            length: value.length
          });
        }
        return sendSuccessData(res, result, "Listing of collections completed successfully");
      });
      server.all("" + channel + "/:collectionName/*", function(req, res) {
        var additionalFields, collectionName, err, method, relativePath;
        method = req.method.toLowerCase();
        if (method === 'get') {
          collectionName = req.params.collectionName;
          relativePath = req.params[0];
          additionalFields = req.query.additionalFields || req.query.additionalfields;
          getFilesFromRequest(req, function(err, files) {
            if (err) {
              return sendError(res, err);
            }
            return sendSuccessData(res, prepareCollection(files, additionalFields), "Listing of " + collectionName + " at " + relativePath + " completed successfully");
          });
        } else if (method === 'delete') {
          deleteFilesFromRequest(req, function(err, files) {
            if (err) {
              return sendError(res, err);
            }
              fs.readFile(__dirname + '/../../../src/layouts/regenerate.html.eco', function(err, data) {
                  if (err) console.log(err);

                  fs.writeFile(__dirname + '/../../../src/layouts/regenerate.html.eco', data, function(err) {
                      if (err) console.log(err);

                      console.log('regenerate.html.eco resaved');
                  });
              });
            return sendSuccessData(res, prepareCollection(files, additionalFields), "Delete completed successfully");
          });
        } else if (method === 'put') {
          additionalFields = req.query.additionalFields || req.query.additionalfields;
          createFileFromRequest(req, function(err, file) {
            if (err) {
              return sendError(res, err);
            }
            return sendSuccessData(res, prepareFile(file, additionalFields), "Creation completed successfully");
          });
        } else if (method === 'post') {
          additionalFields = req.query.additionalFields || req.query.additionalfields;
          updateFileFromRequest(req, function(err, file) {
            if (err) {
              return sendError(res, err);
            }
            return sendSuccessData(res, prepareFile(file, additionalFields), "Update completed successfully");
          });
        } else {
          err = Error("Unknown method: " + method);
          sendError(res, err);
        }
      });
      return this;
    };

    return RestAPI;

  })(BasePlugin);
};
